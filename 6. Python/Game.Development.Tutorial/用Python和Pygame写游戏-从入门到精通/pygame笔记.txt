

set_mode会返回一个Surface对象，代表了在桌面上出现的那个窗口，3个参数.
第1个为元祖，代表分辨率(必须)
第2个是一个标志位, 具体意思见下表, 如果不用什么特性, 就指定0；
第3个为色深。

标志位		功能
FULLSCREEN	创建一个全屏窗口
DOUBLEBUF	创建一个“双缓冲”窗口，建议在HWSURFACE或者OPENGL时使用
HWSURFACE	创建一个硬件加速的窗口，必须和FULLSCREEN同时使用
OPENGL		创建一个OPENGL渲染的窗口
RESIZABLE	创建一个可以改变大小的窗口
NOFRAME		创建一个没有边框的窗口



convert函数是将图像数据都转化为Surface对象，每次加载完图像以后就应该做这件事件
(事实上因为它太常用了, 如果你不写pygame也会帮你做);
convert_alpha相比convert，保留了Alpha 通道信息(可以简单理解为透明的部分)，这样我们的光标才可以是不规则的形状。

游戏的主循环是一个无限循环，直到用户跳出。在这个主循环里做的事情就是不停地画背景和更新光标位置，
虽然背景是不动的，我们还是需要每次都画它， 否则鼠标覆盖过的位置就不能恢复正常了。



blit是个重要函数，第一个参数为一个Surface对象，第二个为左上角位置。
画完以后一定记得用update更新一下，否则画面一片漆黑。

---------------------------------------------------------------------------
显示图像的一部分
    image_part = (10,10,30,30) # 图像区域的左,上,宽,高
    screen.blit(background, (0,0), image_part )




---------------------------------------------------------------------------

【显示字体】


为了使用字体，你得先创建一个Font对象，对于系统自带的字体：
	my_font = pygame.font.SysFont("arial", 16)


你也可以使用pygame.font.get_fonts()来获得当前系统所有可用字体。


还有一个更好的方法的，使用TTF的方法：
	my_font = pygame.font.Font("my_font.ttf", 16)

这个语句使用了一个叫做“my_font.ttf”，这个方法之所以好是因为你可以把字体文件随游戏一起分发，避免用户机器上没有需要
的
字体。

[一旦你创建了一个font对象，你就可以使用render方法来写字了，然后就能blit到屏幕上]
text_surface = my_font.render("Pygame is cool!", True, (0,0,0), (255, 255, 255))

	第一个参数是写的文字；
	第二个参数是个布尔值，以为这是否开启抗锯齿，就是说True的话字体会比较平滑，不过相应的速度有一点点影响；
	第三个参数是字体的颜色；
	第四个是背景色，如果你想没有背景色（也就是透明），那么可以不加这第四个参数。



追加说明一下如何显示中文，这在原书可是没有的哦:)
简单来说，首先你得用一个可以使用中文的字体，宋体、黑体什么的，或者你直接用中文TTF文件，
然后文字使用unicode，即u”中文的文字”这种，
最后不要忘了源文件里加上一句关于文件编码的“魔法注释”
# -*- coding: utf-8 -*-
# 记住上面这行是必须的，而且保存文件的编码要一致！


---------------------------------------------------------------------------

对于Pygame而已，加载图片就是pygame.image.load，给它一个文件名然后就还给你一个surface对象。
尽管读入的图像格式各不相同，surface对象隐藏了这些不同。
你可以对一个Surface对象进行涂画、变形、复制等各种操作。
事实上，屏幕也只是一个surface，pygame.display.set_mode就返回了一个屏幕surface对象。


剪裁(Clipping)

通常游戏的时候你只需要绘制屏幕的一部分。比如魔兽上面是菜单，下面是操作面板，中间的小兵和英雄打的不可开交时候，上下的
部分也是保持相对不动的。为了实现这一点，surface就有了一种叫裁剪区域（clipping area)的东西，也是一个矩形，定义了
哪部分会被绘制，也就是说一旦定义了这个区域，那么只有这个区域内的像素会被修改，其他的位置保持不变，默认情况下，这个区
域是所有地方。我们可以使用set_clip来设定，使用get_clip来获得这个区域。

子表面(Subsurfaces)

Subsurface就是在一个Surface中再提取一个Surface，记住当你往Subsurface上画东西的时候，同时也向父表面上操作。这
可以用来绘制图形文字，尽管pygame.font可以用来写很不错的字，但只是单色，游戏可能需要更丰富的表现，这时候你可以把每个
字母（中文的话有些吃力了）各自做成一个图片，不过更好的方法是在一张图片上画满所有的字母。把整张图读入，然后再用
Subsurface把字母一个一个“抠”出来，就像下面这样：



Blitting

blit的的中文翻译给人摸不着头脑的感觉，可以译为位块传送（bit block transfer），
其意义是将一个平面的一部分或全部图象整块从这个平面复制到另一个平面，下面还是直接使用英文。



---------------------------------------------------------------------------

使用了pygame.event.get()来处理所有的事件，这好像打开大门让所有的人进入。
如果我们使用pygame.event.wait()，Pygame就会等到发生一个事件才继续下去，就好像你在门的猫眼上盯着外面一样，
来一个放一个……一般游戏中不太实用，因为游戏往往是需要动态运作的；
而另外一个方法pygame.event.poll()就好一些，一旦调用，它会根据现在的情形返回一个真实的事件，或者一个“什么都没有”



-----------------------------------------------------------------------------------------
【Clock对象】


我们需要知道上一个画面到现在经过了多少时间，然后我们才能决定是否开始绘制下一幅。

pygame.time模块给我们提供了一个Clock的对象，使我们可以轻易做到这一点：

	clock = pygame.time.Clock()
	time_passed = clock.tick()
	time_passed = clock.tick(30)

第一行初始化了一个Clock对象；

第二行的意思是返回一个上次调用的时间（以毫秒计）；

第三行非常有用，在每一个循环中加上它，那么给tick方法加上的参数就成为了游戏绘制的最大帧率，
这样的话，游戏就不会用掉你所有的CPU资源了！
但是这仅仅是“最大帧率”，并不能代表用户看到的就是这个数字，
有些时候机器性能不足，或者动画太复杂，实际的帧率达不到这个值，我们需要一种更有效的手段来控制我们的动画效果。



从上一帧开始到现在，小鱼应该游动了多少像素，这个算法很简单，速度*时间就行了，



为了使得在不同机器上有着一致的效果，我们其实是需要给定物体（我们把这个物体叫做精灵，Sprite）恒定的速度。
这样的话，从起点到终点的时间点是一样的，最终的效果也就相同了，所差别的，只是流畅度。




我们把上面的结论实际试用一下，假设让我们的小鱼儿每秒游动250像素，这样游动一个屏幕差不多需要2.56秒。
我们就需要知道，从上一帧开始到现在，小鱼应该游动了多少像素，这个算法很简单，速度*时间就行了，
也就是250 * time_passed_second。
不过我们刚刚得到的time_passed是毫秒，不要忘了除以1000.0，当然我们也能假设小鱼每毫秒游动0.25像素
这样就可以直接乘了，不过这样的速度单位有些怪怪的……


---------------------------------------------------------------------------------------
pygame.key.get_pressed()来获得所有按下的键值，它会返回一个元组。
这个元组的索引就是键值，对应的就是是否按下, 比如说：

pressed_keys = pygame.key.get_pressed()
if pressed_keys[K_SPACE]:
    # 空格键被按下
    fire()pressed_keys = pygame.key.get_pressed()



当然key模块下还有很多函数：

key.get_focused —— 当前激活的pygame窗口
key.get_pressed —— 刚刚解释过了
key.get_mods —— 按下的组合键（Alt, Ctrl, Shift）
key.set_mods —— 你也可以模拟按下组合键的效果（KMOD_ALT, KMOD_CTRL, KMOD_SHIFT）
key.set_repeat —— 设定允许pygame接受重复按键
key.name —— 接受键值返回键




总结一下pygame.mouse的函数：
pygame.mouse.get_pressed -- 返回按键按下情况，返回的是一元组，分别为(左键, 中键, 右键)，如按下则为True

pygame.mouse.get_rel -- 返回相对偏移量，(x方向, y方向)的一元组
pygame.mouse.get_pos -- 返回当前鼠标位置(x, y)
pygame.mouse.set_pos -- 显而易见，设置鼠标位置
pygame.mouse.set_visible -- 设置鼠标光标是否可见
pygame.mouse.get_focused -- 如果鼠标在pygame窗口内有效，返回True
pygame.mouse.set_cursor -- 设置鼠标的默认光标式样，是不是感觉我们以前做的事情白费了？
哦不会，我们使用的方法有着更好的效果。
pyGame.mouse.get_cursor  获得鼠标的默认光标样式 。










































